'use strict';

const path = require('path');
const execa = require('execa');
const fs = require('node:fs/promises');
const yargs = require('yargs');
const chalk = require('chalk');
const dotenv = require('dotenv');
const { cleanTestApp, generateTestApp } = require('../helpers/test-app');
const { pathExists, readFile, writeFile } = require('../helpers/fs');

/**
 * Shared test runner infrastructure for both e2e and cli tests
 */
class SharedTestRunner {
  constructor(options) {
    this.cwd = path.resolve(__dirname, '../..');
    this.testAppDirectory = path.join(this.cwd, 'test-apps', options.testType);
    this.testRoot = path.join(this.cwd, 'tests', options.testType);
    this.testDomainRoot = path.join(this.testRoot, 'tests');
    this.templateDir = path.join(this.testRoot, 'app-template');
    this.testType = options.testType;
    this.runner = options.runner; // Function that handles the specific test execution
  }

  /**
   * Updates the env file for a generated test app
   * - Removes the PORT key/value from generated app .env
   * - Adds required environment variables for tests
   * - Uses app-template/config/features.js to enable future features in the generated app
   */
  async setupTestEnvironment(generatedAppPath) {
    /**
     * Because we're running multiple test apps at the same time
     * and the env file is generated by the generator with no way
     * to override it, we manually remove the PORT key/value so when
     * we set it further down for each test instance it works.
     */
    const pathToEnv = path.join(generatedAppPath, '.env');
    const envFile = await readFile(pathToEnv);
    let envWithoutPort = envFile.replace('PORT=1337', '');

    // Add required environment variables for tests
    const requiredEnvVars = [
      'ADMIN_JWT_SECRET=aSecret',
      'API_TOKEN_SALT=aSecret',
      'TRANSFER_TOKEN_SALT=aSecret',
      'JWT_SECRET=aSecret',
      'ENCRYPTION_KEY=example-key',
      'APP_KEYS=toBeModified1,toBeModified2',
    ];

    // Add the required environment variables if they don't already exist
    requiredEnvVars.forEach((envVar) => {
      const [key] = envVar.split('=');
      if (!envWithoutPort.includes(`${key}=`)) {
        envWithoutPort += `\n${envVar}`;
      }
    });

    await writeFile(pathToEnv, envWithoutPort);

    /*
     * Enable future features in the generated app manually since a template
     * does not allow the config folder.
     */
    const testRootFeaturesConfigPath = path.join(this.templateDir, 'config', 'features.js');
    const hasFeaturesConfig = await pathExists(testRootFeaturesConfigPath);

    if (!hasFeaturesConfig) return;

    const configFeatures = await readFile(testRootFeaturesConfigPath);
    const appFeaturesConfigPath = path.join(generatedAppPath, 'config', 'features.js');
    await writeFile(appFeaturesConfigPath, configFeatures);
  }

  /**
   * Publish all packages to the yalc store
   */
  async publishPackages() {
    await execa('node', [path.join(__dirname, '../..', 'scripts', 'yalc-publish.js')], {
      stdio: 'inherit',
    });
  }

  /**
   * Setup test apps
   */
  async setupTestApps(domains, concurrency, setup) {
    const testAppsToSpawn = Math.min(domains.length, concurrency);

    if (testAppsToSpawn === 0) {
      throw new Error('No test apps to spawn');
    }

    const testAppPaths = Array.from({ length: testAppsToSpawn }, (_, i) =>
      path.join(this.testAppDirectory, `test-app-${i}`)
    );

    let currentTestApps = [];

    try {
      currentTestApps = await fs.readdir(this.testAppDirectory);
    } catch (err) {
      // no test apps exist, okay to fail silently
    }

    /**
     * If we don't have enough test apps, we make enough.
     * You can also force this setup if desired, e.g. you
     * update the app-template.
     */
    if (setup || currentTestApps.length < testAppsToSpawn) {
      /**
       * this will effectively clean the entire directory before hand
       * as opposed to cleaning the ones we aim to spawn.
       */
      await Promise.all(
        currentTestApps.map(async (testAppName) => {
          const appPath = path.join(this.testAppDirectory, testAppName);
          console.log(`cleaning test app at path: ${chalk.bold(appPath)}`);
          await cleanTestApp(appPath);
        })
      );

      await Promise.all(
        testAppPaths.map(async (appPath) => {
          console.log(`generating test apps at path: ${chalk.bold(appPath)}`);
          await generateTestApp({
            appPath,
            database: {
              client: 'sqlite',
              connection: {
                filename: './.tmp/data.db',
              },
              useNullAsDefault: true,
            },
            template: this.templateDir,
            link: true,
          });

          await this.setupTestEnvironment(appPath);
        })
      );

      console.log(
        `${chalk.green('Successfully')} setup test apps for the following domains: ${chalk.bold(
          domains.join(', ')
        )}`
      );
    } else {
      console.log(
        `Skipping setting up test apps, use ${chalk.bold('--setup')} to force the setup process`
      );
    }

    return testAppPaths;
  }

  /**
   * Run tests using the specific runner
   */
  async runTests(domains, testAppPaths, concurrency, argv) {
    return await this.runner({
      domains,
      testAppPaths,
      concurrency,
      argv,
      testRoot: this.testRoot,
      testDomainRoot: this.testDomainRoot,
      cwd: this.cwd,
    });
  }

  /**
   * Clean test apps
   */
  async cleanTestApps() {
    try {
      const currentTestApps = await fs.readdir(this.testAppDirectory);

      if (currentTestApps.length === 0) {
        console.log(`No ${this.testType} test apps to clean`);
        return;
      }

      await Promise.all(
        currentTestApps.map(async (testAppName) => {
          const appPath = path.join(this.testAppDirectory, testAppName);
          console.log(`cleaning test app at path: ${chalk.bold(appPath)}`);
          await cleanTestApp(appPath);
        })
      );
    } catch (err) {
      console.error(chalk.red(`Error cleaning ${this.testType} test apps:`));
      console.error(err);
      process.exit(1);
    }
  }

  /**
   * Main execution method
   */
  async execute(argv) {
    try {
      // Load environment variables if they exist
      if (await pathExists(path.join(this.testRoot, '.env'))) {
        dotenv.config({ path: path.join(this.testRoot, '.env') });
      }

      const { concurrency, domains, setup } = argv;

      // Publish packages
      await this.publishPackages();

      // Setup test apps
      const testAppPaths = await this.setupTestApps(domains, concurrency, setup);

      // Run tests
      await this.runTests(domains, testAppPaths, concurrency, argv);
    } catch (err) {
      console.error(chalk.red(`Error running ${this.testType} tests:`));
      if (err.shortMessage) {
        console.error(err.shortMessage);
        process.exit(1);
      }
      console.error(err);
      process.exit(1);
    }
  }

  /**
   * Create yargs command configuration
   */
  createCommand() {
    const self = this;
    return {
      command: '*',
      description: `run the ${this.testType.toUpperCase()} test suite`,
      async builder(yarg) {
        const domains = await fs.readdir(self.testDomainRoot);

        yarg.option('concurrency', {
          alias: 'c',
          type: 'number',
          default: domains.length,
          describe: `Number of concurrent test apps to run, a test app runs an entire test suite domain`,
        });

        yarg.option('domains', {
          alias: 'd',
          describe: 'Run a specific test suite domain',
          type: 'array',
          choices: domains,
          default: domains,
        });

        yarg.option('setup', {
          alias: 'f',
          describe: 'Force the setup process of the test apps',
          type: 'boolean',
          default: false,
        });
      },
      async handler(argv) {
        await self.execute(argv);
      },
    };
  }

  /**
   * Create clean command
   */
  createCleanCommand() {
    const self = this;
    return {
      command: 'clean',
      description: `clean the test app directory of all ${this.testType} test apps`,
      async handler() {
        await self.cleanTestApps();
      },
    };
  }
}

module.exports = SharedTestRunner;
