While the goal is to eventually provide individual test cases for every path through createMetadata, in the meantime this guide will explain how to update the test data to ensure it has full coverage of database identifiers.

It was generated by taking the getstarted project and making the following changes to the schema:

in content-types/temp add:

```js
    "selfManyToMany": {
    "type": "relation",
    "relation": "manyToMany",
    "target": "api::temp.temp",
    "inversedBy": "selfManyToManyInv"
    },
    "selfManyToManyInv": {
    "type": "relation",
    "relation": "manyToMany",
    "target": "api::temp.temp",
    "inversedBy": "selfManyToMany"
    },
    "bidirectionalAddress": {
    "type": "relation",
    "relation": "manyToOne",
    "target": "api::address.address",
    "inversedBy": "bidirectionalTemps",
    "useJoinTable": false
    }
```

in content-types/address add:

```js
    "bidirectionalTemps": {
      "type": "relation",
      "relation": "oneToMany",
      "target": "api::temp.temp",
      "mappedBy": "bidirectionalAddress"
    }
```

The input models and output metadata can be easily logged using the following method. It can be temporarily added directly to the `createMetadata` method for dev purposes.

```js
const map2str = (map: Map<string, unknown>, keyStartsWith?: string) => {
  // Filter map entries if keyStartsWith is provided
  const filteredEntries = keyStartsWith
    ? Array.from(map.entries()).filter(([key]) => key.startsWith(keyStartsWith))
    : Array.from(map.entries());

  return JSON.stringify(filteredEntries, null, 2);
};

writeFileSync('models.ts', `export const models = ${JSON.stringify(models, undefined, 2)}`);
writeFileSync('expected-metadata.ts', `export const metadata = ${map2str(metadata)}`);
```
